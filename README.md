# 1C_task
I am trying to think of something

# Идея: 
пройтись префикс функцией по строке, если в большом массиве нашли первую строку, ищем в следущей строке большого массива вторую строку фрагмента, если нет - переходим

# Оценка для массива n * m, фрагмента k * l:
Работа поиска одной подстроки Theta(n + k), то есть O(n). Поиск предположительно О(n*l) ~ O(n*m).

# Особенность этой реализации
Программа пока не ищет Север/Юг. Не очень воспринимает ситуацию когда истинное начало фрагмента лежит правее предполагаемого. Пример найти столбец {1, 1} в таблице {{1, 0}, {1, 1}}.
Программа найдет совпадение по первой строке и вернет индекс 0 - начала совпадения. Для второй строки она вернет индекс 1. Как с этим бороться? Возможно возвращать массив индексов совпадающих подстрок и искать в них совпадения. 
